{"version":3,"file":"murmurhash2_x86_32.js.map","sources":["../src/_shared.js","../src/murmurhash2_x86_32.js"],"sourcesContent":["/**\n * Returns a multiple unsigned int32\n *\n * @private\n * @param {number} x Non linear base\n * @param {number} y Linear base\n * @return {number} Unsigned int32\n */\nexport function uMul32Getter(x, y) {\n    x = x | 0;\n    y = y | 0;\n    const nonLinear = x & 0xffff;\n    const linearBase = x >>> 16;\n\n    return (nonLinear * y + (((linearBase * y) & 0xffff) << 16)) | 0;\n}\n\n/**\n * Return an unsigned int32 from hash by position\n *\n * @private\n * @param {string} hash String hash value\n * @param {number} position String start position\n * @return {number} Unsigned int32\n */\nexport function uInt32Getter(hash, position) {\n    return (\n        hash.charCodeAt(position++) +\n        (hash.charCodeAt(position++) << 8) +\n        (hash.charCodeAt(position++) << 16) +\n        (hash.charCodeAt(position) << 24)\n    );\n}\n\n/**\n * Throw an error if the given seed is invalid for a murmur hash algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidMurmurSeed(seed) {\n    if (seed !== undefined && seed % 1 !== 0) {\n        throw new TypeError('Expected seed to be an integer, float given');\n    }\n}\n\n/**\n * Throw an error if the given seed is invalid for the alea algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidAleaSeed(seed) {\n    if (seed % 1 !== 0 || seed <= 0) {\n        throw new TypeError(\n            `Expected seed to be an unsigned integer greater 1, but got \"${seed}\"`\n        );\n    }\n}\n","/** @module number-generator/lib/murmurhash2_x86_32 */\nimport { uMul32Getter, uInt32Getter, throwInvalidMurmurSeed } from './_shared';\n\n/**\n * Generate a non-cryptic number hash with murmur2 algorithm\n *\n * From {@link https://gist.github.com/raycmorgan/588423}\n * Ray Morgan, 2011\n * Refactored and extended from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash2_x86_32\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} hash The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {number} Generated number\n */\nexport default (() => {\n    const MULTIPLIER = 0x5bd1e995;\n    const BASE = 24;\n\n    /**\n     * Return an unsigned int16 from hash by position\n     *\n     * @private\n     * @param {string} hash String hash value\n     * @param {number} position String start position\n     * @return {number} Unsigned int16\n     */\n    const uInt16Getter = (hash, position) =>\n        hash.charCodeAt(position++) + (hash.charCodeAt(position) << 8);\n\n    /**\n     * Generate a non-cryptic number hash with murmur2 algorithm\n\n     * @throws {TypeError} Throws an exception if seed is a float\n     * @param {string} hash The base string hash to generate number\n     * @param {number} [seed=0] An optional seed value\n     * @return {number} Generated number\n     */\n    function murmurhash2_x86_32(hash, seed = 0) {\n        throwInvalidMurmurSeed(seed);\n\n        let currentIndex = 0;\n        let hashSum = seed ^ hash.length;\n        let length = hash.length;\n\n        while (length >= 4) {\n            let calculated = uInt32Getter(hash, currentIndex);\n\n            calculated = uMul32Getter(calculated, MULTIPLIER);\n            calculated ^= calculated >>> BASE;\n            calculated = uMul32Getter(calculated, MULTIPLIER);\n\n            hashSum = uMul32Getter(hashSum, MULTIPLIER);\n            hashSum ^= calculated;\n\n            currentIndex += 4;\n            length -= 4;\n        }\n\n        switch (length) {\n            case 3:\n                hashSum ^= uInt16Getter(hash, currentIndex);\n                hashSum ^= hash.charCodeAt(currentIndex + 2) << 16;\n                hashSum = uMul32Getter(hashSum, MULTIPLIER);\n                break;\n            case 2:\n                hashSum ^= uInt16Getter(hash, currentIndex);\n                hashSum = uMul32Getter(hashSum, MULTIPLIER);\n                break;\n            case 1:\n                hashSum ^= hash.charCodeAt(currentIndex);\n                hashSum = uMul32Getter(hashSum, MULTIPLIER);\n                break;\n        }\n\n        hashSum ^= hashSum >>> 13;\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        hashSum ^= hashSum >>> 15;\n\n        return hashSum >>> 0;\n    }\n\n    return murmurhash2_x86_32;\n})();\n"],"names":["uMul32Getter","x","y","uInt32Getter","hash","position","charCodeAt","throwInvalidMurmurSeed","seed","undefined","TypeError","MULTIPLIER","BASE","uInt16Getter","currentIndex","hashSum","length","calculated"],"mappings":"aAQO,SAASA,aAAaC,EAAGC,UAGN,OAFtBD,GAAQ,KACRC,GAAQ,MAEWD,IAAM,IAEeC,EAAK,QAAW,IAAO,EAW5D,SAASC,aAAaC,EAAMC,UAE3BD,EAAKE,WAAWD,MACfD,EAAKE,WAAWD,MAAe,IAC/BD,EAAKE,WAAWD,MAAe,KAC/BD,EAAKE,WAAWD,IAAa,IAU/B,SAASE,uBAAuBC,WACtBC,IAATD,GAAsBA,EAAO,GAAM,QAC7B,IAAIE,UAAU,+CC1B5B,uBAAe,eACLC,EAAa,WACbC,EAAO,GAUPC,EAAe,SAACT,EAAMC,UACxBD,EAAKE,WAAWD,MAAeD,EAAKE,WAAWD,IAAa,oBAUpCD,OAAMI,yDAAO,EACrCD,uBAAuBC,WAEnBM,EAAe,EACfC,EAAUP,EAAOJ,EAAKY,OACtBA,EAASZ,EAAKY,OAEXA,GAAU,GAAG,KACZC,EAAad,aAAaC,EAAMU,GAEpCG,EAAajB,aAAaiB,EAAYN,GAEtCM,EAAajB,aADbiB,GAAcA,IAAeL,EACSD,GAEtCI,EAAUf,aAAae,EAASJ,GAChCI,GAAWE,EAEXH,GAAgB,EAChBE,GAAU,SAGNA,QACC,EACDD,GAAWF,EAAaT,EAAMU,GAE9BC,EAAUf,aADVe,GAAWX,EAAKE,WAAWQ,EAAe,IAAM,GAChBH,cAE/B,EAEDI,EAAUf,aADVe,GAAWF,EAAaT,EAAMU,GACEH,cAE/B,EAEDI,EAAUf,aADVe,GAAWX,EAAKE,WAAWQ,GACKH,UAKxCI,EAAUf,aADVe,GAAWA,IAAY,GACSJ,IAChCI,GAAWA,IAAY,MAEJ,GAhEZ"}